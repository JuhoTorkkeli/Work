Class ZenApp1.App1 Extends (%Persistent, %XML.Adaptor) [ Inheritance = left ]
{

/* PÄÄSIVUN ALAINEN OHJELMALUOKKA JOKA TOIMII MYÖS SELLAISENAAN */
Property DateAndTime As %TimeStamp [ Required ];

Property EventType As %String;

Property Computer As %String;

Property SourceName As %String;

Property EventId As %Integer;

Property Message As %Text(MAXLEN = 5000);

/*Ajetaan terminaalissa syntaksilla: do class##(ZenApp1.App1).lueTiedosto()*/

/*Ohjelma avaa kaikki HTML-tiedostot määritetystä hakemistopolusta ohjelman alussa (set directory = hakemistopolku), lukee jokaisesta 'New W3SVC Messages in System Event Log' -tiedostosta määritellyt rivit, muokkaa ne (Propertyt määritelty ylempänä) ja tallentaa ne tietokantaan objekteina. Lisäksi nimeää luetut HTML-tiedostot uudelleen (laittaa perään (OK) samassa hakemistopolussa).*/

/*Ohjelma ei vertaa (OK)-tiedostoja uusien tiedostojen kanssa seuraavalla kerralla, kun ohjelmaa ajetaan (käyttäjä tarkkana ettei hakemistopolkuun viedä samaa tiedostoa toiseen kertaan!!!). Käyttäjän pitää myöskin tarkistaa error-kansioon viedyt tiedostot itse (pistää errorLog:iin talteen tiedot). Tallentaa objekteja tietokantaan tiedostoista niin kauan, kunnes ohjelma havaitsee virheen (laittaa errorLog:iin rivit, joissa virhe tapahtui)*/

/*errorLog:iin tallennettujen rivien avulla Notepad++ -ohjelmalla paikannetaan virhe*/

/*Käyttäjä voi päättää miltä riviltä lähtien ohjelma lähtee tallentamaan tiedostosta objekteja tietokantaan saveFromLine parametrin avulla (arvo tallennettu errorLog:iin) tiedoston manuaalisen korjauksen jälkeen.*/

/*saveFromLine = objektirivi, jolta lähdetään tallentamaan objekteja tietokantaan (ohjelma nollaa saveFromLine arvon ensimmäisen tiedoston luvun jälkeen)*/
ClassMethod lueTiedosto(saveFromLine = 0) As %Boolean
{
	set directory = "C:\Users\TT\Desktop\Juho\App1Testi"

	set (objectNumber, objectLine, error, oRivi, i) = 0 
	;Alustetaan 'objectNumber', jonka avulla katsotaan kuinka monta objektia tallennettiin tietokantaan jokaisesta tiedostosta erikseen.
	;Alustetaan 'objectLine', jota käytetään aliohjelmassa 'createObject' objektinluonnissa.
	;Alustetaan 'error', jota käytetään jos HTML-tiedostoja ei löydy hakemistopolusta tai objektintallennus-error tilanteissa ehtona ohjelman lopetukselle.
	;Alustetaan 'oRivi', jota käytetään laskettaessa 'saveFromLine' kanssa montako objektia jätetään välistä tallennettaessa objekteja tietokantaan.
	;Alustetaan 'i', jota käytetään ensimmäiseksi aliohjelmassa 'showFiles'.
	
	do showFiles(directory) ;Aliohjelmaan 'showFiles' viedään pääohjelman alussa määritelty hakemistopolku, jossa taulukkoon tallennetaan kaikki HTML-tiedostot.
	if (error = 1) {write "Yhtään avattavaa HTML-tiedostoa ei löytynyt hakemistopolusta: ", !, directory, ! quit 0}
	
	set i = 1 ;Alustetaan 'i' jota käytetään uudestaan seuraavassa aliohjelmassa 'compareFiles'.
	for {
		set cf = $$compareFiles() ;Verrataan HTML-tiedostoja toisiinsa ettei kahta täysin samanlaista ole vahingossa eksynyt hakemistopolkuun.
		if (cf = 0){ ;Jos tiedosto ei ole samanlainen minkään muun avattavan tiedoston kanssa..
			set file = ##class(%File).%New(fileNamePaths(i)) ;..Lähdetään avaamaan tiedostoja taulukosta 'fileNamePaths(i)'.
			do file.Open("R",2)
			if 'file.IsOpen {write !, "Tiedosto: ", !, fileNamePaths(i), !, "ei auennut!" quit} ;Jos tiedosto ei aukea siirrytään seuraavaan tiedostoon. Näiden tiedostojen perään ei tule (OK), niitä ei siirretä error-kansioon ja ne ajetaan uudelleen seuraavalla kerralla.
			
			do readFile(file) ;Viedään tiedosto luettavaksi aliohjelmaan 'readFile'.
			if (error = 0){ ;Jos tiedostossa ei ollut minkäänlaista virhettä..
				write !, objectNumber, " Objektia luotiin tietokantaan tiedostosta: ", !, fileNamePaths(i)
				set className = "write ^" _ $ClassName() _ "D" ;'className' -muuttujaan ylös globaalin nimi.
				write !, "Objekteja tietokannassa yhteensä: " Xecute className ;Xecute-komennolla ajetaan 'className' -muuttujassa oleva rivi.
				set objectNumber = 0 ;Nollataan 'objectNumber', jotta seuraavan tiedoston objektien lukumäärä saadaan erilleen.
				write !, viiva
				do file.Close() ;Tiedosto pitää sulkea, jos sen haluaa nimetä uudelleen. (Muuten heittää ERROR #00)
				set newFileName = $$renameFileName(fileNamePaths(i)) ;Haetaan tiedostolle uusi nimi, kun siitä on tallennettu tiedot tietokantaan.
				do renameFile(fileNamePaths(i), newFileName) ;Viedään tiedosto uudelleennimettäväksi renameFile:en.
			}
			else { ;Jos avatussa tiedostossa oli virhe..
				do file.Close() ;Suljetaan tiedosto ennen sen siirtämistä error-kansioon.
				do moveFileToError(fileNamePaths(i), fileNames(i)) ; Siirretään virheellinen tiedosto error-kansioon.
				do createErrorLog(fileNames(i)) ;Kirjataan tiedot errorLog:iin.
				write !!, objectNumber, " Objektia luotiin tietokantaan tiedostosta: ", !, fileNamePaths(i)
				write !, viiva
				set (objectLine, error, objectNumber) = 0 
				;Nollataan objectLine, jos jossain virheellisessä tiedostossa on ollut puuttuva määrä tarvittavia rivejä.
				;Nollataan error tilanne ennen kuin toista tiedostoa lähdetään avaamaan.
				;Nollataan objectNumber, jotta saamme seuraavan tiedoston objektien lukumäärän erilleen.
				do pressToContinue()
				write !, viiva
			}
		}	
		set i = i + 1
		set saveFromLine = 0
		quit:($get(fileNamePaths(i)) = "") ;Lopetetaan ohjelma jos HTML-tiedostoja ei ole enää jäljellä luettavaksi.
	}
	write !
	quit 1
	
showFiles(dir) ;Tallennetaan kaikki HTML-tiedostot määritetystä hakemistopolusta kahteen eri taulukkoon 'fileNames' ja 'fileNamePaths'.
	set rs = ##class(%ResultSet).%New("%Library.File:FileSet") ;Otetaan käsittelyyn kaikki tiedostot (Windowsissa?).
	do rs.Execute(dir, "*", "Type") ;Ajetaan hakemistopolusta "dir = alussa määritelty hakemistopolku" kaikki tiedot "* = all" järjestyksessä "Type = tiedostopääte" mukaan.
	write "Avatut HTML-tiedostot: "
	
	while rs.Next(){ ;Niin kauan kuin tiedostoja löytyy hakemistopolusta, ne käydään lävitse ja HTML-tiedostojen nimet otetaan ylös.
		set fileNamePath = rs.GetData(1) ;Näyttää koko hakemistopolun.
		set fileName = rs.GetData(6) ;Näyttää vain tiedostonimen.
		if '(fileName?.e1"(OK)"1"."1"html"){ ;Ei lueta mukaan jo luettuja tiedostoja (OK).
			if (fileNamePath?.e1"."1"html"){ ;Jos halutaan lukea muita kuin HTML-loppuisia tiedostoja tästä voidaan vaihtaa pääte tarkastamaan muunlaisia.
				set i = $increment(i)
				write !, fileNamePath
				set fileNamePaths(i) = fileNamePath ;Tallennetaan ensimmäiseen taulukkoon tiedostojen hakemistopolut..
				set fileNames(i) = fileName ;..ja toiseen taulukkoon pelkät tiedostonimet.
			}
			else{
				if (fileName?.e1".".e){ ;Kaikki muunlaiset tiedostot siirretään error-kansioon.
				do moveFileToError(fileNamePath, fileName)
				write !, "Tiedosto: '" , fileName, "' siirrettiin error-kansioon!"
				do pressToContinue()
				}
			}
		}
	}
	if $get(fileNamePaths(i)) = "" { ;Jos ensimmäistäkään HTML-tiedostoa ei löytynyt, ohjelma palauttaa virheen ja se loppuu pääohjelmassa.
		do rs.Close()
		set error = 1
		quit
	}
	do viiva()
	write !, viiva
	do rs.Close()
	quit
	
moveFileToError(errorFile, newFileLocation) ;Vääränlaiset ja virheelliset HTML-tiedostot viedään error-kansioon. Jos error-kansiota ei ole olemassa, se luodaan.
	if $extract(directory, $length(directory)) '= "\" {set errorDir = directory _ "\Error"}
	else {set errorDir = directory _ "Error"}
	if '##class(%File).DirectoryExists(errorDir){
		set sc = ##class(%File).CreateNewDir(directory, "Error")
		if $$$ISERR(sc) {
			do $System.Status.DisplayError(sc)
			write !, "Kansiota: " _ errorDir _" ei voitu luoda!", !
			}
	}
	set newErrorFile = errorDir _ "\" _ newFileLocation
	set fileToMove = ##class(%File).Rename(errorFile, newErrorFile) ;Siirretään väärä/virheellinen tiedosto error-kansioon.
	quit
	
viiva()	;Tehdään viiva terminaaliin viimeisimmän hakemistopolun pituuden mukaan (hahmotusta varten).
	set pituus = $length(fileNamePaths(i))
	set viiva = "-"
	for i = 1:1:pituus {set viiva = viiva _ "-"}
	if ($length(viiva) > 80){set viiva = $extract(viiva, 1, 80)}
	quit
	
compareFiles() ;Verrataan avattuja HTML-tiedostoja toisiinsa tehdyssä taulukossa fileNamePaths, ettei tässä vaiheessa hakemistopolkuun ole eksynyt kahta samanlaista tiedostoa.
	set cf = 0
	for j = 1:1 {
		if $data(fileNamePaths(i+j)){
			set cf = ##class(%File).Compare(fileNamePaths(i), fileNamePaths(i+j)) ;Verrataan taulukon ensimmäistä tiedostoa muihin. Jo verrattuja ei näin tarvitse alkaa uudelleen vertaamaan seuraavien avattavien tiedostojen kanssa.
			if (cf = 1){
				write !, "Tiedosto: ", !, fileNamePaths(i), !, "on identtinen tiedoston: ",!, fileNamePaths(i+j), " kanssa!"
				do moveFileToError(fileNamePaths(i), fileNames(i))
				write !, viiva
				do pressToContinue()
				write !, viiva
				quit 
			}
		}
		quit:($data(fileNamePaths(i+j)) = 0) ;Jos seuraavaa tiedostoa ei enää löydy verrattavaksi tämä aliohjelma päättyy.
	}
	quit cf ;Palautetaan arvo takaisin pääohjelmaan. Jos ensimmäinen tiedosto on täysin samanlainen jonkun muun kanssa, vasta viimeisin samanlainen tiedosto luetaan tietokantaan (koska viimeistä tiedostoa ei tulla vertaamaan samanlaisiin).
	
pressToContinue() ;Tätä aliohjelmaa käytetään vain käyttäjän havainnollistamisen parantamiseksi error-tilanteissa.
	read !, ">>>Press any key to continue<<<", y#1:3
	quit
	
readFile(file) ;Luetaan tiedosto rivi riviltä viimeiseen riviin asti.
	while 'file.AtEnd { ;Kunnes viimeinen tiedoston rivi on luettu..
		set line = file.ReadLine() ;Otetaan talteen jokainen rivi erikseen..
		set eRivi = $increment(eRivi) ;Otetaan talteen rivien kokonaislukumäärä eRivi:in.
		if (line?.E1"<TD><tt>".E1"</tt></TD>"){ ;Jos rivi on halutunlainen sen alussa saa olla tyhjää ja mitä tahansa tietoa tagien välissä.
			set objectLine = $increment(objectLine)
			set oLine(objectLine) = line ;oLine:en tallennetaan alkuperäiset rivit.
			set line = $$editLine(line) ;Viedään muokattavaksi tulevat objektiksi tallennettavat rivit editLine:een.
			do createObject(line) ;Viedään objektin osat yksi kerrallaan createObject:iin.
		}
		if (error = 1){quit} ;Jos createObject palauttaa virheen tiedoston luku loppuu ja pääohjelmassa siirrytään seuraavaan tiedostoon.
	}
	if (objectLine > 0) && (objectLine < 6){
		set error = 1 set errorText = "Puuttuu rivejä!" write !, "ERROR: objectLine < 6; tiedostossa: ", !, fileNamePaths(i), !, "ei ole tarvittavia rivejä, jotka vaaditaan tallennettavaksi tietokantaan!"
		}
	quit

editLine(line) ;Muokataan lause ja viedään se createObject:iin.
	set line = $piece($piece(line,">",3),"<",1) ;Otetaan pois tagit yms.
	if (line?1.2N1"."1.2N1"."2.4N1" "1.2N1":"1.2N1":"1.2N){ ;Jos kyseessä on aika..
		set line = $replace(line, ".", "/")
		set line = $ZDATETIME($ZDATETIMEH(line, 4), 3) ;..muunnetaan se timestamp formaattiin.
	}
	quit line

createObject(line) ;Luodaan objekti 6:sta rivistä (oletetaan rivien olevan tässä järjestyksessä): DateAndTime (Time reserved word sql), EventType, Computer, SourceName, EventId ja Message.
	if (objectLine = 1){set App1Oref=##class(ZenApp1.App1).%New() 
						set App1Oref.DateAndTime=line}
	if (objectLine = 2){set App1Oref.EventType=line}
	if (objectLine = 3){set App1Oref.Computer=line}
	if (objectLine = 4){set App1Oref.SourceName=line}
	if (objectLine = 5){set App1Oref.EventId=line}
	if (objectLine = 6){set App1Oref.Message=line
						if (oRivi = saveFromLine){ ;Jos käyttäjä on antanut saveFromLine:en arvon alkaa objektien tallennus vasta oRivi:n saavutettua kyseisen arvon.
							set Save=App1Oref.%Save() ;Kun tarpeeksi rivejä on tuotu tallennetaan se objektina tietokantaan.
							if '$$$ISERR(Save){
								set objectNumber = $increment(objectNumber)
							}
							else {
								do $System.Status.DisplayError(Save)
								write !
								set errorText = $System.Status.GetErrorText(Save)
								set error = 1
							}
						}
						else {
							set oRivi = $increment(oRivi)
							}
						set counter = objectLine ;counter ottaa talteen jokaisen objektin tallennuksen yhteydessä rivien määrän (ei tiedoston rivien kokonaismäärää), jotka kirjoitetaan errorLogiin.
						set objectLine = 0
	}
	quit
	
createErrorLog(fns) ;Kirjoittaa moveFileToError -aliohjelmassa luotuun errorLogiin kaikissa ajetuissa tiedostoissa tapahtuneet virhetilanteet.
	set fc = ##class(%Stream.FileCharacter).%New()
	set fc.Filename = errorDir _ "\errorLog.txt"
	do fc.MoveToEnd()
	do fc.WriteLine("Aika: " _ $zdatetime($h, 3))
	do fc.WriteLine("File: " _ fns)
	do fc.WriteLine("Virhe: " _ errorText)
	do fc.WriteLine("Rivit: " _ (eRivi - 5) _ " - " _ eRivi) ;Laitetaan ylös errorLogiin rivit, joissa virhe tapahtui (Jos rivejä tallentuu väärä määrä arvo saattaa heittää errorLogissa)
	for k = 1:1:counter {do fc.WriteLine(oLine(k))} ;Lisätään errorLogiin rivit, joissa virhe tapahtui.
	do fc.WriteLine("SaveFromLine: " _ objectNumber) ;Lisätään saveFromLine arvo loppuun, jonka avulla käyttäjä voi ajaa ensimmäisen tiedoston halutulta objektiriviltä manuaalisen korjauksen jälkeen.
	do fc.WriteLine(viiva)
	do fc.%Save()
	write !, "errorLog luotiin/päivitettiin kansioon: ", !
	write errorDir _ "\errorLog.txt"
	quit
	
renameFileName(fileName) ;Tiedoston perään lisätään "(OK)" kun siitä on tallennettu tiedot tietokantaan.
	set fileNamePiece1 = $piece(fileName, ".", 1)
	set fileNamePiece2 = $piece(fileName, ".", 2)
	set newFileName = fileNamePiece1 _ "(OK)" _ "." _ fileNamePiece2
	quit newFileName ;Palautetaan uusi tiedostonimi, joka viedään renameFile:en pääohjelmassa.
	
renameFile(oFileName, newFileName) ;Tiedosto nimetään uudelleen, jotta sitä ei seuraavalla kerralla (kun ohjelmaa ajetaan) luettaisi uudelleen.
	set renamedFile = ##class(%File).Rename(oFileName, newFileName) ;Samalla metodilla "Rename" tiedosto voidaan myös siirtää muualle.
	if $$$ISERR(renamedFile){
		do $System.Status.DisplayError(renamedFile)
		write !, "Tiedostoa: ", !, oFileName, !, "ei voitu nimetä uudelleen tiedostoksi: "
		write !, newFileName, !, viiva
		do pressToContinue()
	}
	quit
}

/*deleteGlobalData ajetaan erikseen ZenApp1.HomePage:sta, jos tiedot halutaan poistaa tietokannasta (ei poista itse globaalia).*/

/*procedureBlock = 1, jotta voidaan palauttaa arvot(killCount, count) takaisin ZenApp1.HomePage.deleteGlobalData:an*/
ClassMethod deleteGlobalData(killCount As %Integer = 0, count As %Integer = 0) [ ProcedureBlock = 1 ]
{
	if ($data(^ZenApp1.App1D)) = 11 { ;Katsotaan löytyykö poistettavia tietoja tietokannasta.
		set x = $order(^ZenApp1.App1D(""), -1) ;Poistetaan loppupäästä -1.
		while (x '= ""){ ;Niin kauan kuin poistettavia löytyy...
			kill ^ZenApp1.App1D(x) ;Poistetaan ne...
			set killCount = $increment(killCount) ;...ja lisätään 1 killCount.			
			set x = $order(^ZenApp1.App1D(x), -1)
		}
		set y = $order(^ZenApp1.App1D("")) ;Alustetaan y, jolla katsotaan löytyykö subscriptejä globaalista.
		while (y '= "") { ;Niin kauan kuin subscriptejä löytyy...
			set count = $increment(count) ;Otetaan ylös niiden lukumäärä count:iin...
			set y = $order(^ZenApp1.App1D(y))
		}
		set ^ZenApp1.App1D = count ;Ja muutetaan ^ZenApp1.App1D arvo subscriptien lukumäärän mukaiseksi.
		write killCount _ " objektia poistettiin tietokannasta! Tietokannassa jäljellä " _ count _ " objektia!"
		quit $$$OK
	}
	else {quit $$$ERROR()}
}

}
